
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>main</title><meta name="generator" content="MATLAB 9.11"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2022-05-06"><meta name="DC.source" content="main.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">Project_Group_2</a></li><li><a href="#2">Lab2_Exercise_2.1</a></li><li><a href="#3">(a) First Part: a signal that &#8220;chirps&#8221; up to a very high frequency,</a></li><li><a href="#4">2.1</a></li><li><a href="#5">2.1 (a) Second Part: Determine the parameters for the signal</a></li><li><a href="#6">2.1(b) Generate the signal and plot in spectrogram with short section length</a></li><li><a href="#8">2.1 c</a></li><li><a href="#9">Lab2_Exercise_2.2</a></li><li><a href="#10">2.2.1:Spectrogram of Periodic Triangle Wave</a></li><li><a href="#11">2.2.2:Decibels (dB): Seeing Small Values in the Spectrogram</a></li><li><a href="#12">2.2.3: Spectrogram in dB</a></li><li><a href="#13">Lab3_Exercise_3.1</a></li><li><a href="#14">Plots for the 2D-FFT of the images for visual representation of the</a></li><li><a href="#15">Lab3_Exercise_3.2</a></li><li><a href="#16">This first part sets up the scaled down image from 3.1.</a></li><li><a href="#17">Part a: Plot the vector xr1hold to verify that it is a zero-order hold version derived from xr1. Explain what values are contained in the indexing vector nn. If xr1hold is treated as an interpolated version of xr1, then what is the interpolation factor?</a></li><li><a href="#18">Part b: Display xholdrows as an image, and compare it to the downsampled image xx3; compare the size of the images as well as their content.</a></li><li><a href="#19">Part C: Now process all the columns of xholdrows to fill in the missing points in each column and and call the result xhold. Compare the result (xhold) to the original image lighthouse</a></li><li><a href="#20">Part D: For the example above, what is the interpolation factor when converting xr1 to xr1linear?</a></li><li><a href="#21">Part E: In the case of the lighthouse image, you need to carry out a linear interpolation operation on both the rows and columns of the down-sampled image xx3. This requires two calls to the interp1 function, because one call will only process all the columns of a matrix. 10 Name the interpolated output image xxlinear. Include your code for this part in the lab report.</a></li><li><a href="#22">Part F: Compare xxlinear to the original image lighthouse. Comment on the visual appearance of the "re-constructed&#8221; image versus the original; point out differences and similarities. Can the reconstruction (i.e., zooming) process remove the aliasing effects from the down-sampled lighthouse image?</a></li><li><a href="#23">Part G: Compare the quality of the linear interpolation result to the zero-order hold result. Point out regions where they differ and try to justify this difference by estimating the local frequency content. In other words, look for regions of "low-frequency" content and &#8220;high-frequency&#8221; content and see how the interpolation quality is dependent on this factor.</a></li><li><a href="#24">function declarations</a></li></ul></div><h2 id="1">Project_Group_2</h2><p>Submitted by Ekata Mitra,Joshua Jacob, Elias Skinner,Ritaja Das</p><pre class="codeinput">clear; clc;
</pre><h2 id="2">Lab2_Exercise_2.1</h2><p>ECE 6530 Matlab Project2 -- Ekata Mitra</p><h2 id="3">(a) First Part: a signal that &#8220;chirps&#8221; up to a very high frequency,</h2><p>and the instantaneous frequency goes past half the sampling rate: A linear-FM (chirp) signal is an ideal test signal to explore the concept of aliasing due to sampling. By visualizing the spectrogram of a synthesized chirp we experience the fact that a D-to-C converter cannot create output signals: with frequencies higher than one half of the sampling frequency. Clearly, it can be said that: f_s/2 &lt;f_max : case of aliasing If a signal goes past the half the sampling rate, the frequencies that are recorded in the discrete approximation of the continuous signal are those of lower frequencies. Since f_s/2 is the Nyquist frequency and the analog signal has a frequency higher than the Nyquist frequency, aliasing takes place.</p><h2 id="4">2.1</h2><p>The starting frequency is 1000 Hz at t=0s. f_st = 1000 Hz. The final frequency is 11,000 Hz at t = 4s. chirp rate = (11000-1000)/4 = 2500Hz/s. The instantaneous frequency (fi(t)) goes from 1000Hz at t=0s to 11000Hz at t=4s slope of instantaneous frequency = 2*mu formula: 2*mu*4 + 1000 = 11000 mu = (11000-1000)/8 Given sampling frequency(f_s) = 4000Hz, Highest Frequency of Input Signal(f_max) : 11000Hz</p><h2 id="5">2.1 (a) Second Part: Determine the parameters for the signal</h2><p>Sampling Frequecy</p><pre class="codeinput">f_s = 4000;
<span class="comment">% Starting Frequency</span>
f_st = 1000;
<span class="comment">% Ending Frequency</span>
f_end = 11000;
<span class="comment">% Chirp signal Start Time</span>
t_st = 0;
<span class="comment">% Chirp signal End Time</span>
t_end = 4;
<span class="comment">% formula for finding Slope of instantaneous frequency:</span>
<span class="comment">% 2*mu = (f_end - f_st)/(t_end -t_st)</span>
<span class="comment">% slope =2*mu</span>
mu = (f_end-f_st)/(2*(t_end -t_st));
<span class="comment">% Time Step</span>
dt = 1/f_s;
<span class="comment">% Time Vector</span>
tt = t_st:dt:t_end;
<span class="comment">% Random Initial Phase</span>
phi = 2*pi*rand;
<span class="comment">% Code for generating chirp signal</span>
<span class="comment">% Signal Phase for all times</span>
psi = 2 * pi * mu * tt.^2 + 2 * pi * f_st * tt + phi;
<span class="comment">% Chirp Signal</span>
cc = real(7.7 * exp(1j*psi));
<span class="comment">% plot for visualization</span>
figure;
<span class="comment">% function plotspec</span>
<span class="comment">% him = plotspec(xx,fsamp,Lsect)</span>
<span class="comment">%       him = handle to the image object</span>
<span class="comment">%        xx = input signal</span>
<span class="comment">%     fsamp = sampling rate</span>
<span class="comment">%     Lsect = section length (integer number of samples, should be power of 2)</span>
<span class="comment">%               amount of data to Fourier analyze at one time</span>
<span class="comment">% L_sect =512;</span>
plotspec(cc, f_s, 512);
xlabel(<span class="string">'Time(sec)'</span>);
ylabel(<span class="string">'Frequency(Hz)'</span>);
</pre><img vspace="5" hspace="5" src="main_01.png" alt=""> <h2 id="6">2.1(b) Generate the signal and plot in spectrogram with short section length</h2><p>The section duration is equal to (Section length / Sampling Frequency). Here is the spectrogram that is plotted for Lsect = 120. Let, L_sect = 128 T_sect = L_sect/f_s = 128/4000s = 0.0320 s function plotspec him = plotspec(xx,fsamp,Lsect)       him = handle to the image object        xx = input signal     fsamp = sampling rate     Lsect = section length (integer number of samples, should be power of 2)               amount of data to Fourier analyze at one time L_sect =128</p><p>Code for generating chirp signal</p><pre class="codeinput">L_sect = 128;
<span class="comment">% Time Step</span>
dt = 1/f_s;
<span class="comment">% Time Vector</span>
tt = t_st:dt:t_end;
<span class="comment">% Random Initial Phase</span>
phi = 2*pi*rand;
<span class="comment">% Signal Phase for all times</span>
psi = 2 * pi * mu * tt.^2 + 2 * pi * f_st * tt + phi;
<span class="comment">% Chirp Signal</span>
cc = real(7.7 * exp(1j*psi));

<span class="comment">% plot for visualization</span>
figure;

plotspec(cc, f_s, L_sect);
xlabel(<span class="string">'Time(sec)'</span>);
ylabel(<span class="string">'Frequency(Hz)'</span>);
</pre><img vspace="5" hspace="5" src="main_02.png" alt=""> <h2 id="8">2.1 c</h2><p>This is because of Aliasing. Here f_s/2 = 2000 Hz. Therefore, 2000 Hz is the maximum frequency that can be recorded in this discrete approximation of the signal. At higher values,i.e., when the signal frequency goes over 2000 Hz, the frequency wraps around the 2000 Hz limit and decreases to 0 when f_s = 4000 Hz. Again, it now continues to increase to 2000 Hz, until the instantaneous frequency is 6000 Hz, and then goes back to 0 at 8000 Hz and so on. This phenomenon is called aliasing</p><h2 id="9">Lab2_Exercise_2.2</h2><pre class="codeinput"><span class="comment">%Submitted by Ritaja Das(u1373636)</span>
<span class="comment">% 2.2 :Spectrogram of Periodic Signal</span>
clear;
<span class="comment">%A periodic signal is known to have a Fourier Series,</span>
<span class="comment">% which is usually described as a harmonic line spectrum because the</span>
<span class="comment">% only frequencies present in the spectrum are integer multiples of</span>
<span class="comment">% the fundamental frequency.</span>
<span class="comment">% With the spectrogram, it is easy to exhibit this harmonic line</span>
<span class="comment">% characteristic.In this section we will be doing exactly that.</span>
</pre><h2 id="10">2.2.1:Spectrogram of Periodic Triangle Wave</h2><pre class="codeinput"><span class="comment">%(a)Here we are generating a triangular periodic signal with</span>
<span class="comment">% period(T) of 10ms</span>
<span class="comment">% peak amplitude(Amp) of 0.5</span>
<span class="comment">% sampling rate fs=10000 Hz</span>

fs = 10e3; <span class="comment">%sampling rate</span>
T = 10e-3; <span class="comment">%period</span>
Amp = 0.5; <span class="comment">%amplitude</span>
tStop = 3;
tt=0:(1/fs):tStop;
qq=rem(tt,T);
xx=Amp*(abs(qq-(0.5*T))-0.25*T);
figure;
subplot(2,1,1);
plot(xx);
xlabel(<span class="string">'T'</span>);
ylabel(<span class="string">'Amplitude'</span>);
title(<span class="string">'Input signal'</span>);

<span class="comment">%(b)short section of the input signal for 5 periods</span>

n=5; <span class="comment">% for 5 periods</span>
Tp=n*T;
ttp=0:(1/fs):Tp;
qqp=rem(ttp,T);
xxp=Amp*(abs(qqp-(0.5*Tp))-0.25*Tp);
subplot(2,1,2);
plot(xxp);
title(<span class="string">'Short section of input signal consisting 5 periods'</span>);
xlabel(<span class="string">'T'</span>);
ylabel(<span class="string">'Amplitude'</span>);


<span class="comment">%(c)Picking a long section duration that is equal to an integer number of periods of</span>
<span class="comment">% the periodic triangular waveform created in the previous part.</span>
<span class="comment">% Defining TSECT for 5 periods, Here Tsect=Tp</span>
<span class="comment">% Lsect=Tp*fs and using the section length in plotspec function</span>

Lsect=Tp * fs;
figure;
plotspec(xx,fs,Lsect);

<span class="comment">%(d)list of all the harmonic frequencies visible at the harmonic line</span>
<span class="comment">%spectrum:100Hz,300Hz,500Hz,700Hz,900Hz,1100Hz,1300Hz</span>

<span class="comment">%(e)fundamental frequency for the harmonic lines : 100Hz</span>

<span class="comment">%(f)amplitude of the first harmonic : 100</span>
<span class="comment">%   amplitude of the third harmonic : 500</span>
<span class="comment">%   ratio of first &amp; third harmonic : 1/5</span>
</pre><img vspace="5" hspace="5" src="main_03.png" alt=""> <img vspace="5" hspace="5" src="main_04.png" alt=""> <h2 id="11">2.2.2:Decibels (dB): Seeing Small Values in the Spectrogram</h2><pre class="codeinput"><span class="comment">%(a)In the language of dB, a factor of two is "6 dB."</span>
<span class="comment">% If B2 is 6 dB bigger than B1, then it is twice as big (approximately).</span>
<span class="comment">% This is true because On a dB scale, a numbers are represented with logarithms</span>
<span class="comment">% so the ratio B2/B1 becomes 20log10(B2/B1)</span>
<span class="comment">% B2/B1 =2 then 20log10(B2/B1)=20log10(2) which equals to 6.02 and</span>
<span class="comment">% intepreted as equal to 6dB</span>

<span class="comment">%(b)The nonzero Fourier coefficients of the triangular wave are</span>
<span class="comment">% ak=-2/(pi^2*k^2)</span>
<span class="comment">% Hence a1= -2/(pi^2*1^2) as k=1 and a3= -2/(pi^2*3^2) as k=3</span>
<span class="comment">% computing we get a1=-2/(pi^2) and a3=-2/(9*pi^2)</span>
<span class="comment">% the ratio of a1/a3=9  dB difference a1/a3=20log109=19.08</span>
<span class="comment">% the dB difference depends only on the k indices since everything else is</span>
<span class="comment">% constant and k is the index for the coefficient number</span>


<span class="comment">%(c)a15=-2/(pi^2*15^2) and a1=-2/(pi^2*1^2) the difference a1-a15=13.9 dB</span>
<span class="comment">%   a15 is 13.9 dB below a1</span>
</pre><h2 id="12">2.2.3: Spectrogram in dB</h2><pre class="codeinput"><span class="comment">%(a):&#8220;dB-Spectrogram&#8221; for the 10-msec periodic triangular wave generated in Sect. 2.2.1. Use a dBrange equal to 80 dB. Notice that many more spectrum lines are now visible.</span>
<span class="comment">% List of all the frequencies: 100Hz,300Hz,500Hz...4900Hz</span>
<span class="comment">% general formula for harmonics : 100+(n-1)200 where n is number of the</span>
<span class="comment">% harmonics</span>


<span class="comment">%(b)another triangle wave with period 20ms and using dbrange=80dB</span>

t=T*2; <span class="comment">% period =20msec</span>
qqt=rem(tt,t);
xxt=Amp*(abs(qqt-(0.5*t))-0.25*t);
figure;
plotspecDB(xxt,fs,Lsect,80);

<span class="comment">%the highest frequency= 4900Hz using the general formula from the equation</span>
<span class="comment">% 100+(n-1)200=4900 using this we get n=24</span>


<span class="comment">%(c)measure of amplitudes(dB) of the first and third harmonics from the</span>
<span class="comment">%spectrogram : a1/a3=1/5</span>

<span class="comment">%(d)taking the period=4msec</span>
<span class="comment">%when period is shorter the frequency separation of the harmonic lines is greater</span>

ts=4*2; <span class="comment">% period =4msec</span>
qqts=rem(tt,ts);
xxts=Amp*(abs(qqts-(0.5*ts))-0.25*ts);
figure;
plotspecDB(xxts,fs,Lsect,80);
</pre><img vspace="5" hspace="5" src="main_05.png" alt=""> <img vspace="5" hspace="5" src="main_06.png" alt=""> <h2 id="13">Lab3_Exercise_3.1</h2><p>ECE 6530 Matlab Project2 -- Elias Skinner Down-Sampling</p><pre class="codeinput">clear;

<span class="comment">% (a)	Figure 1 shows the original image next to the down-sampled image.</span>
<span class="comment">% The down-sampled image is the one of the right of the figure. Figure 2</span>
<span class="comment">% is just of the original image and the Figure 3 is just of the down-sample</span>
<span class="comment">% image. The aliasing is most noticeable on the white fence in the</span>
<span class="comment">% right-hand side of the image. The aliasing is also very apparent on the</span>
<span class="comment">% walls of the buildings next to the lighthouse. Visually this aliasing</span>
<span class="comment">% appears as a moir&eacute; pattern. This phenomenon appears as geometric</span>
<span class="comment">% artifacts that do not actually exist in the image. Edges are also a lot</span>
<span class="comment">% starker and rougher in the aliased photo. For example, when looking at</span>
<span class="comment">% the side of the lighthouse where it meets the sky, the interfaces between</span>
<span class="comment">% the two has more defined pixel transitions where the non-aliased photo</span>
<span class="comment">% has a smoother transition between these interfaces.</span>

<span class="comment">% (b)	The highest frequency of the fence that is most apparently aliased</span>
<span class="comment">% appears to be 2 pixels per cycle (from fence post to fence post). This is</span>
<span class="comment">% right on the edge of what the Nyquist frequency for capturing the fence.</span>
<span class="comment">% With down sampling the photo by a factor of two, this is placing the</span>
<span class="comment">% sampling frequency below what can properly capture the fence. This</span>
<span class="comment">% distortion in the detail creates these geometric artifacts known as moir&eacute;</span>
<span class="comment">% patterns.</span>

load <span class="string">lighthouse</span>;    <span class="comment">%loads the lightouse image into variable xx</span>

<span class="comment">% figure;  %Figure 1 shows the orignal image right next to the down-sampled image</span>
<span class="comment">% hold on;</span>
<span class="comment">% subplot(1, 2, 1);</span>
<span class="comment">%</span>
<span class="comment">% imshow(xx); %Displays original image</span>
<span class="comment">% title('Original Image');</span>
<span class="comment">%</span>
xp = xx(1:2:end,1:2:end);   <span class="comment">%Down-sample the original image by a factor of 2</span>
size(xp);   <span class="comment">%Compensate for the size of the down-sampled image</span>
<span class="comment">%subplot(1, 2, 2);</span>
<span class="comment">%</span>
<span class="comment">% imshow(xp);  %Display down-sampled image</span>
<span class="comment">% title('Down-Sample Image');</span>
<span class="comment">% hold off;</span>

figure;  <span class="comment">%Display original image by itself</span>

imshow(xx);
title(<span class="string">'Original Image'</span>);

figure;  <span class="comment">%Display down-sampled image by itself</span>

imshow(xp);
title(<span class="string">'Down-Sample Image'</span>);
</pre><img vspace="5" hspace="5" src="main_07.png" alt=""> <img vspace="5" hspace="5" src="main_08.png" alt=""> <h2 id="14">Plots for the 2D-FFT of the images for visual representation of the</h2><pre class="codeinput"><span class="comment">%frequency domain</span>

xf = fft2(xx);
figure;
hold <span class="string">on</span>;
imshow(abs(fftshift(xf)));
title(<span class="string">"FFT of original image"</span>)
hold <span class="string">off</span>;

xfp = fft2(xp);
figure;
hold <span class="string">on</span>;
imshow(abs(fftshift(xfp)));
title(<span class="string">"FFT of Down-sampled image"</span>)
hold <span class="string">off</span>;

figure;
hold <span class="string">on</span>;
imagesc(abs(fftshift(xf))); <span class="comment">%Shift 0 point to origin on plot and change color scaling</span>
title(<span class="string">"FFT of original image"</span>)
hold <span class="string">off</span>;

figure;
hold <span class="string">on</span>;
imagesc(abs(fftshift(xfp))); <span class="comment">%Shift 0 point to origin on plot and change color scaling</span>
title(<span class="string">"FFT of Down-sampled image"</span>);
hold <span class="string">off</span>;
</pre><img vspace="5" hspace="5" src="main_09.png" alt=""> <img vspace="5" hspace="5" src="main_10.png" alt=""> <img vspace="5" hspace="5" src="main_11.png" alt=""> <img vspace="5" hspace="5" src="main_12.png" alt=""> <h2 id="15">Lab3_Exercise_3.2</h2><pre class="codeinput">clear;
<span class="comment">% Reconstruction of images- Joshua Jacob</span>
</pre><h2 id="16">This first part sets up the scaled down image from 3.1.</h2><pre class="codeinput">clear;

load <span class="string">lighthouse</span>;
xx3 = xx;
show_img(xx);
title(<span class="string">"Original Image"</span>)
xpix = ones(256,1)*cos(2*pi*(0:255)/16);
xx3 = xx3(1:3:size(xx3,1),1:3:size(xx3,2));
show_img(xx3)
title(<span class="string">"Down Sampled"</span>)
</pre><pre class="codeoutput">Image being scaled so that min value is 0 and max value is 255
Image being scaled so that min value is 0 and max value is 255

ans = 

  Axes with properties:

             XLim: [0.5000 142.5000]
             YLim: [0.5000 109.5000]
           XScale: 'linear'
           YScale: 'linear'
    GridLineStyle: '-'
         Position: [0.1316 0.1108 0.7717 0.8134]
            Units: 'normalized'

  Use GET to show all properties

</pre><img vspace="5" hspace="5" src="main_13.png" alt=""> <img vspace="5" hspace="5" src="main_14.png" alt=""> <h2 id="17">Part a: Plot the vector xr1hold to verify that it is a zero-order hold version derived from xr1. Explain what values are contained in the indexing vector nn. If xr1hold is treated as an interpolated version of xr1, then what is the interpolation factor?</h2><p>The indexing vector nn contains the values at which the zero hold interpolated version should be evaluated at. These values are determined by the length of the original vector along with the interpolation factor. In this case the interpolation factor is 4. Xr1hold essentially stretches out xr1</p><pre class="codeinput">xr1 = (-2).^(0:6);
L = length(xr1);
nn = ceil((0.999:1:4*L)/4);
xr1hold = xr1(nn);
plot(xr1hold);
title(<span class="string">"Plot of xr1hold"</span>)
</pre><img vspace="5" hspace="5" src="main_15.png" alt=""> <h2 id="18">Part b: Display xholdrows as an image, and compare it to the downsampled image xx3; compare the size of the images as well as their content.</h2><p>The size here is 3 times the size of the down sampled image lengthwise. We see that the image size is now approximately the same as the orignal image lengthwise. We see some distortion and blurring along with the introduction of new artifacts</p><pre class="codeinput">xholdrows = zeros(size(xx3,1),size(xx3,2)*3);
indices = ceil((0.999:1:3*size(xx3,2))/3);
<span class="keyword">for</span> i = 1:size(xx3,1)
    temp = xx3(i,:);
    xholdrows(i,:) = temp(indices);
<span class="keyword">end</span>
show_img(xholdrows);
title(<span class="string">"Zero hold row interpolation"</span>)
</pre><pre class="codeoutput">Image being scaled so that min value is 0 and max value is 255
</pre><img vspace="5" hspace="5" src="main_16.png" alt=""> <h2 id="19">Part C: Now process all the columns of xholdrows to fill in the missing points in each column and and call the result xhold. Compare the result (xhold) to the original image lighthouse</h2><p>We now see the same sort of stretching as before except now the size nearly matches the original image in all directions. We see more distrotion and mismatched details.</p><pre class="codeinput">xhold = zeros(size(xholdrows,1)*3,size(xholdrows,2));
indices = ceil((0.999:1:3*size(xholdrows,1))/3);
<span class="keyword">for</span> i = 1:size(xholdrows,2)
    temp = xholdrows(:,i);
    xhold(:,i) = temp(indices);
<span class="keyword">end</span>
show_img(xhold)
title(<span class="string">"Zero hold full interpolation"</span>)
</pre><pre class="codeoutput">Image being scaled so that min value is 0 and max value is 255

ans = 

  Axes with properties:

             XLim: [0.5000 426.5000]
             YLim: [0.5000 327.5000]
           XScale: 'linear'
           YScale: 'linear'
    GridLineStyle: '-'
         Position: [0.1302 0.1108 0.7745 0.8134]
            Units: 'normalized'

  Use GET to show all properties

</pre><img vspace="5" hspace="5" src="main_17.png" alt=""> <h2 id="20">Part D: For the example above, what is the interpolation factor when converting xr1 to xr1linear?</h2><p>I have kept this code as a comment however the interpolation factor in this code is 10 n1 = 0:6; xr1 = (-2).&#710;n1; tti = 0:0.1:6; -- locations between the n1 indices xr1linear = interp1(n1,xr1,tti);</p><pre class="codeinput"><span class="comment">%-- function is INTERP-ONE</span>
<span class="comment">% stem(tti,xr1linear)</span>
</pre><h2 id="21">Part E: In the case of the lighthouse image, you need to carry out a linear interpolation operation on both the rows and columns of the down-sampled image xx3. This requires two calls to the interp1 function, because one call will only process all the columns of a matrix. 10 Name the interpolated output image xxlinear. Include your code for this part in the lab report.</h2><p>THe code required is below</p><pre class="codeinput">n1 = 1:size(xx3,1);
n2 = 1:size(xx3,2);
tti1 = 1:1/3:size(xx3,1);
tti2 = 1:1/3:size(xx3,2);
xxlinear1 = interp1(n1,xx3,tti1);
xxlinear = interp1(n2,xxlinear1',tti2);
xxlinear = xxlinear';
show_img(xxlinear);
title(<span class="string">"Linear interpolation"</span>)
</pre><pre class="codeoutput">Image being scaled so that min value is 0 and max value is 255
</pre><img vspace="5" hspace="5" src="main_18.png" alt=""> <h2 id="22">Part F: Compare xxlinear to the original image lighthouse. Comment on the visual appearance of the "re-constructed&#8221; image versus the original; point out differences and similarities. Can the reconstruction (i.e., zooming) process remove the aliasing effects from the down-sampled lighthouse image?</h2><p>The Re construction looks blurrier than the original image however it avoids some of the aliasing present in the zero hold interpolation. However, it can not avoid all aliasing.</p><h2 id="23">Part G: Compare the quality of the linear interpolation result to the zero-order hold result. Point out regions where they differ and try to justify this difference by estimating the local frequency content. In other words, look for regions of "low-frequency" content and &#8220;high-frequency&#8221; content and see how the interpolation quality is dependent on this factor.</h2><p>The linear interpolation looks better in my opinion than the zero hold result. Even though some new information is created and objects distroted, it looks more like just a simple blur rather than jagged and hard to figure out anomalies. Spots along the fence and roof make the differences most clear where we can see blurring and jagged edges, but in areas like the sky where not much changes all the images are approximately the same.</p><h2 id="24">function declarations</h2><pre class="codeinput"><span class="comment">%PLOTSPECDB plot a Spectrogram as an image</span>
<span class="comment">% (display magnitude in decibels)</span>
<span class="comment">% usage: him = plotspec(xx,fsamp,Lsect,DBrange)</span>
<span class="comment">% him = handle to the image object</span>
<span class="comment">% xx = input signal fsamp = sampling rate Lsect = section length (integer, power of 2 is a good choice) amount of data to Fourier analyze at one time</span>
<span class="comment">% DBrange = defines the minimum dB value; max is always 0 dB</span>
<span class="keyword">function</span> [ him ] = plotspecDB( xx, fsamp, Lsect, DBrange )

<span class="keyword">if</span> (nargin &lt; 4)

disp(<span class="string">'PLOTSPECDB: DB range defaulting to 60 dB'</span>);

DBrange = 60;

<span class="keyword">end</span>

<span class="keyword">if</span> (nargin &lt; 3)

Lsect = 256;

<span class="keyword">end</span>

<span class="keyword">if</span> (nargin &lt; 2)

disp(<span class="string">'PLOTSPECDB: Sampling Frequency defaulting to 8000 Hz'</span>);

fsamp = 8000;

<span class="keyword">end</span>

<span class="keyword">if</span> (length(xx) &lt; 1000)

disp(<span class="string">'WARNING: Signal Length should be greater than 1000'</span>);

<span class="keyword">end</span>

Lfft = Lsect;

Noverlap = round(Lsect/2);

[B,F,T] = spectgr(xx, Lfft, fsamp, Lsect, Noverlap);

Bdb = 20*log10(abs(B));

Bmax = max(Bdb(:));

Bdb = Bdb - Bmax;

Bmin = -DBrange;

Bdb = Bdb.*(Bdb&gt;=Bmin)+ Bmin.*(Bdb&lt;Bmin);

him = imagesc(T,F,Bdb);

axis <span class="string">xy</span>;
xlabel(<span class="string">'Time(sec)'</span>);
ylabel(<span class="string">'Frequency(Hz)'</span>);
colormap(1-gray);
<span class="keyword">end</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2021b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Project_Group_2
% Submitted by Ekata Mitra,Joshua Jacob, Elias Skinner,Ritaja Das
clear; clc;
%% Lab2_Exercise_2.1
% ECE 6530 Matlab Project2 REPLACE_WITH_DASH_DASH Ekata Mitra

%% (a) First Part: a signal that “chirps” up to a very high frequency, 
% and the instantaneous frequency goes past half the sampling rate:
% A linear-FM (chirp) signal is an ideal test signal to explore 
% the concept of aliasing due to sampling. 
% By visualizing the spectrogram of a synthesized chirp 
% we experience the fact that a D-to-C converter cannot create 
% output signals:
% with frequencies higher than one half of the sampling frequency.
% Clearly, it can be said that:
% f_s/2 <f_max : case of aliasing
% If a signal goes past the half the sampling rate, 
% the frequencies that are recorded in the discrete
% approximation of the continuous signal are those of lower frequencies. 
% Since f_s/2 is the Nyquist frequency and
% the analog signal has a frequency higher than the Nyquist frequency,
% aliasing takes place.
%%  2.1
% The starting frequency is 1000 Hz at t=0s. 
% f_st = 1000 Hz. 
% The final frequency is 11,000 Hz at t = 4s.
% chirp rate = (11000-1000)/4 = 2500Hz/s.
% The instantaneous frequency (fi(t)) goes from 1000Hz at t=0s to 11000Hz
% at t=4s
% slope of instantaneous frequency = 2*mu
% formula:
% 2*mu*4 + 1000 = 11000  
% mu = (11000-1000)/8
% Given sampling frequency(f_s) = 4000Hz,
% Highest Frequency of Input Signal(f_max) : 11000Hz
%% 2.1 (a) Second Part: Determine the parameters for the signal
% Sampling Frequecy
f_s = 4000; 
% Starting Frequency
f_st = 1000; 
% Ending Frequency
f_end = 11000;
% Chirp signal Start Time
t_st = 0; 
% Chirp signal End Time
t_end = 4; 
% formula for finding Slope of instantaneous frequency:
% 2*mu = (f_end - f_st)/(t_end -t_st)
% slope =2*mu
mu = (f_end-f_st)/(2*(t_end -t_st)); 
% Time Step
dt = 1/f_s;
% Time Vector
tt = t_st:dt:t_end; 
% Random Initial Phase
phi = 2*pi*rand; 
% Code for generating chirp signal
% Signal Phase for all times
psi = 2 * pi * mu * tt.^2 + 2 * pi * f_st * tt + phi; 
% Chirp Signal
cc = real(7.7 * exp(1j*psi)); 
% plot for visualization
figure;
% function plotspec
% him = plotspec(xx,fsamp,Lsect)
%       him = handle to the image object
%        xx = input signal
%     fsamp = sampling rate
%     Lsect = section length (integer number of samples, should be power of 2)
%               amount of data to Fourier analyze at one time
% L_sect =512;
plotspec(cc, f_s, 512);
xlabel('Time(sec)');
ylabel('Frequency(Hz)');
%% 2.1(b) Generate the signal and plot in spectrogram with short section length
% The section duration is equal to (Section length / Sampling Frequency).
% Here is the spectrogram that is plotted for Lsect = 120.
% Let, L_sect = 128
% T_sect = L_sect/f_s = 128/4000s = 0.0320 s
% function plotspec
% him = plotspec(xx,fsamp,Lsect)
%       him = handle to the image object
%        xx = input signal
%     fsamp = sampling rate
%     Lsect = section length (integer number of samples, should be power of 2)
%               amount of data to Fourier analyze at one time
% L_sect =128
%%
% Code for generating chirp signal
L_sect = 128;
% Time Step
dt = 1/f_s; 
% Time Vector
tt = t_st:dt:t_end; 
% Random Initial Phase
phi = 2*pi*rand; 
% Signal Phase for all times
psi = 2 * pi * mu * tt.^2 + 2 * pi * f_st * tt + phi; 
% Chirp Signal
cc = real(7.7 * exp(1j*psi)); 

% plot for visualization
figure;

plotspec(cc, f_s, L_sect);
xlabel('Time(sec)');
ylabel('Frequency(Hz)');
%% 2.1 c
% This is because of Aliasing. 
% Here f_s/2 = 2000 Hz. 
% Therefore, 2000 Hz is the maximum frequency that can be recorded in this
% discrete approximation of the signal. At higher values,i.e.,
% when the signal frequency goes over 2000 Hz, the frequency wraps around 
% the 2000 Hz limit and decreases to 0 when f_s = 4000 Hz.
% Again, it now continues to increase to 2000 Hz,
% until the instantaneous frequency is 6000 Hz, and 
% then goes back to 0 at 8000 Hz and so on. This phenomenon is called aliasing


%% Lab2_Exercise_2.2
%Submitted by Ritaja Das(u1373636)
% 2.2 :Spectrogram of Periodic Signal
clear;
%A periodic signal is known to have a Fourier Series,
% which is usually described as a harmonic line spectrum because the 
% only frequencies present in the spectrum are integer multiples of 
% the fundamental frequency. 
% With the spectrogram, it is easy to exhibit this harmonic line
% characteristic.In this section we will be doing exactly that.

%% 2.2.1:Spectrogram of Periodic Triangle Wave

%(a)Here we are generating a triangular periodic signal with 
% period(T) of 10ms
% peak amplitude(Amp) of 0.5
% sampling rate fs=10000 Hz

fs = 10e3; %sampling rate
T = 10e-3; %period
Amp = 0.5; %amplitude
tStop = 3;
tt=0:(1/fs):tStop;
qq=rem(tt,T);
xx=Amp*(abs(qq-(0.5*T))-0.25*T);
figure;
subplot(2,1,1);
plot(xx);
xlabel('T');
ylabel('Amplitude');
title('Input signal');

%(b)short section of the input signal for 5 periods

n=5; % for 5 periods
Tp=n*T;
ttp=0:(1/fs):Tp;
qqp=rem(ttp,T);
xxp=Amp*(abs(qqp-(0.5*Tp))-0.25*Tp);
subplot(2,1,2);
plot(xxp);
title('Short section of input signal consisting 5 periods');
xlabel('T');
ylabel('Amplitude');


%(c)Picking a long section duration that is equal to an integer number of periods of 
% the periodic triangular waveform created in the previous part. 
% Defining TSECT for 5 periods, Here Tsect=Tp 
% Lsect=Tp*fs and using the section length in plotspec function

Lsect=Tp * fs;
figure;
plotspec(xx,fs,Lsect); 

%(d)list of all the harmonic frequencies visible at the harmonic line
%spectrum:100Hz,300Hz,500Hz,700Hz,900Hz,1100Hz,1300Hz

%(e)fundamental frequency for the harmonic lines : 100Hz

%(f)amplitude of the first harmonic : 100
%   amplitude of the third harmonic : 500
%   ratio of first & third harmonic : 1/5

%% 2.2.2:Decibels (dB): Seeing Small Values in the Spectrogram


%(a)In the language of dB, a factor of two is "6 dB." 
% If B2 is 6 dB bigger than B1, then it is twice as big (approximately).
% This is true because On a dB scale, a numbers are represented with logarithms
% so the ratio B2/B1 becomes 20log10(B2/B1)
% B2/B1 =2 then 20log10(B2/B1)=20log10(2) which equals to 6.02 and
% intepreted as equal to 6dB

%(b)The nonzero Fourier coefficients of the triangular wave are
% ak=-2/(pi^2*k^2)
% Hence a1= -2/(pi^2*1^2) as k=1 and a3= -2/(pi^2*3^2) as k=3  
% computing we get a1=-2/(pi^2) and a3=-2/(9*pi^2)
% the ratio of a1/a3=9  dB difference a1/a3=20log109=19.08
% the dB difference depends only on the k indices since everything else is
% constant and k is the index for the coefficient number


%(c)a15=-2/(pi^2*15^2) and a1=-2/(pi^2*1^2) the difference a1-a15=13.9 dB
%   a15 is 13.9 dB below a1


%% 2.2.3: Spectrogram in dB

%(a):“dB-Spectrogram” for the 10-msec periodic triangular wave generated in Sect. 2.2.1. Use a dBrange equal to 80 dB. Notice that many more spectrum lines are now visible. 
% List of all the frequencies: 100Hz,300Hz,500Hz...4900Hz
% general formula for harmonics : 100+(n-1)200 where n is number of the
% harmonics


%(b)another triangle wave with period 20ms and using dbrange=80dB

t=T*2; % period =20msec
qqt=rem(tt,t);
xxt=Amp*(abs(qqt-(0.5*t))-0.25*t);
figure;
plotspecDB(xxt,fs,Lsect,80);

%the highest frequency= 4900Hz using the general formula from the equation
% 100+(n-1)200=4900 using this we get n=24


%(c)measure of amplitudes(dB) of the first and third harmonics from the
%spectrogram : a1/a3=1/5

%(d)taking the period=4msec
%when period is shorter the frequency separation of the harmonic lines is greater

ts=4*2; % period =4msec
qqts=rem(tt,ts);
xxts=Amp*(abs(qqts-(0.5*ts))-0.25*ts);
figure;
plotspecDB(xxts,fs,Lsect,80);

%% Lab3_Exercise_3.1
% ECE 6530 Matlab Project2 REPLACE_WITH_DASH_DASH Elias Skinner
% Down-Sampling
clear;

% (a)	Figure 1 shows the original image next to the down-sampled image.
% The down-sampled image is the one of the right of the figure. Figure 2 
% is just of the original image and the Figure 3 is just of the down-sample 
% image. The aliasing is most noticeable on the white fence in the 
% right-hand side of the image. The aliasing is also very apparent on the 
% walls of the buildings next to the lighthouse. Visually this aliasing 
% appears as a moiré pattern. This phenomenon appears as geometric 
% artifacts that do not actually exist in the image. Edges are also a lot 
% starker and rougher in the aliased photo. For example, when looking at 
% the side of the lighthouse where it meets the sky, the interfaces between 
% the two has more defined pixel transitions where the non-aliased photo 
% has a smoother transition between these interfaces.

% (b)	The highest frequency of the fence that is most apparently aliased 
% appears to be 2 pixels per cycle (from fence post to fence post). This is 
% right on the edge of what the Nyquist frequency for capturing the fence. 
% With down sampling the photo by a factor of two, this is placing the 
% sampling frequency below what can properly capture the fence. This 
% distortion in the detail creates these geometric artifacts known as moiré 
% patterns.

load lighthouse;    %loads the lightouse image into variable xx

% figure;  %Figure 1 shows the orignal image right next to the down-sampled image
% hold on;
% subplot(1, 2, 1);
% 
% imshow(xx); %Displays original image
% title('Original Image');
% 
xp = xx(1:2:end,1:2:end);   %Down-sample the original image by a factor of 2
size(xp);   %Compensate for the size of the down-sampled image
%subplot(1, 2, 2);
% 
% imshow(xp);  %Display down-sampled image
% title('Down-Sample Image');
% hold off;

figure;  %Display original image by itself

imshow(xx);
title('Original Image');

figure;  %Display down-sampled image by itself

imshow(xp);
title('Down-Sample Image');
%% Plots for the 2D-FFT of the images for visual representation of the
%frequency domain

xf = fft2(xx);
figure;
hold on;
imshow(abs(fftshift(xf)));
title("FFT of original image")
hold off;

xfp = fft2(xp);
figure;
hold on;
imshow(abs(fftshift(xfp)));
title("FFT of Down-sampled image")
hold off;

figure;
hold on;
imagesc(abs(fftshift(xf))); %Shift 0 point to origin on plot and change color scaling 
title("FFT of original image")
hold off;

figure;
hold on;
imagesc(abs(fftshift(xfp))); %Shift 0 point to origin on plot and change color scaling 
title("FFT of Down-sampled image");
hold off;

%% Lab3_Exercise_3.2
clear;
% Reconstruction of images- Joshua Jacob 
%% This first part sets up the scaled down image from 3.1.
clear;

load lighthouse;
xx3 = xx;
show_img(xx);
title("Original Image")
xpix = ones(256,1)*cos(2*pi*(0:255)/16);
xx3 = xx3(1:3:size(xx3,1),1:3:size(xx3,2));
show_img(xx3)
title("Down Sampled")
%% Part a: Plot the vector xr1hold to verify that it is a zero-order hold version derived from xr1. Explain what values are contained in the indexing vector nn. If xr1hold is treated as an interpolated version of xr1, then what is the interpolation factor?
% The indexing vector nn contains the values at which the zero hold
% interpolated version should be evaluated at. These values are determined
% by the length of the original vector along with the interpolation factor.
% In this case the interpolation factor is 4. Xr1hold essentially stretches
% out xr1
xr1 = (-2).^(0:6);
L = length(xr1);
nn = ceil((0.999:1:4*L)/4);
xr1hold = xr1(nn);
plot(xr1hold);
title("Plot of xr1hold")

%% Part b: Display xholdrows as an image, and compare it to the downsampled image xx3; compare the size of the images as well as their content.
% The size here is 3 times the size of the down sampled image lengthwise. We see that 
% the image size is now approximately the same as the orignal image
% lengthwise. We see some distortion and blurring along with the
% introduction of new artifacts
xholdrows = zeros(size(xx3,1),size(xx3,2)*3);
indices = ceil((0.999:1:3*size(xx3,2))/3);
for i = 1:size(xx3,1)
    temp = xx3(i,:);
    xholdrows(i,:) = temp(indices);
end
show_img(xholdrows);
title("Zero hold row interpolation")

%% Part C: Now process all the columns of xholdrows to fill in the missing points in each column and and call the result xhold. Compare the result (xhold) to the original image lighthouse
% We now see the same sort of stretching as before except now the size
% nearly matches the original image in all directions. We see more
% distrotion and mismatched details.

xhold = zeros(size(xholdrows,1)*3,size(xholdrows,2));
indices = ceil((0.999:1:3*size(xholdrows,1))/3);
for i = 1:size(xholdrows,2)
    temp = xholdrows(:,i);
    xhold(:,i) = temp(indices);
end
show_img(xhold)
title("Zero hold full interpolation")

%% Part D: For the example above, what is the interpolation factor when converting xr1 to xr1linear?
% I have kept this code as a comment however the interpolation factor in
% this code is 10
% n1 = 0:6;
% xr1 = (-2).ˆn1;
% tti = 0:0.1:6;
% REPLACE_WITH_DASH_DASH locations between the n1 indices
% xr1linear = interp1(n1,xr1,tti);
%REPLACE_WITH_DASH_DASH function is INTERP-ONE
% stem(tti,xr1linear)

%% Part E: In the case of the lighthouse image, you need to carry out a linear interpolation operation on both the rows and columns of the down-sampled image xx3. This requires two calls to the interp1 function, because one call will only process all the columns of a matrix. 10 Name the interpolated output image xxlinear. Include your code for this part in the lab report.
% THe code required is below
n1 = 1:size(xx3,1);
n2 = 1:size(xx3,2);
tti1 = 1:1/3:size(xx3,1);
tti2 = 1:1/3:size(xx3,2);
xxlinear1 = interp1(n1,xx3,tti1);
xxlinear = interp1(n2,xxlinear1',tti2);
xxlinear = xxlinear';
show_img(xxlinear);
title("Linear interpolation")
%% Part F: Compare xxlinear to the original image lighthouse. Comment on the visual appearance of the "re-constructed” image versus the original; point out differences and similarities. Can the reconstruction (i.e., zooming) process remove the aliasing effects from the down-sampled lighthouse image?
% The Re construction looks blurrier than the original image however it
% avoids some of the aliasing present in the zero hold interpolation.
% However, it can not avoid all aliasing.

%% Part G: Compare the quality of the linear interpolation result to the zero-order hold result. Point out regions where they differ and try to justify this difference by estimating the local frequency content. In other words, look for regions of "low-frequency" content and “high-frequency” content and see how the interpolation quality is dependent on this factor.
% The linear interpolation looks better in my opinion than the zero hold
% result. Even though some new information is created and objects
% distroted, it looks more like just a simple blur rather than jagged and
% hard to figure out anomalies. Spots along the fence and roof make the
% differences most clear where we can see blurring and jagged edges, but in
% areas like the sky where not much changes all the images are
% approximately the same. 











%% function declarations

%PLOTSPECDB plot a Spectrogram as an image
% (display magnitude in decibels) 
% usage: him = plotspec(xx,fsamp,Lsect,DBrange) 
% him = handle to the image object 
% xx = input signal fsamp = sampling rate Lsect = section length (integer, power of 2 is a good choice) amount of data to Fourier analyze at one time 
% DBrange = defines the minimum dB value; max is always 0 dB
function [ him ] = plotspecDB( xx, fsamp, Lsect, DBrange )

if (nargin < 4)

disp('PLOTSPECDB: DB range defaulting to 60 dB');

DBrange = 60;

end

if (nargin < 3)

Lsect = 256;

end

if (nargin < 2)

disp('PLOTSPECDB: Sampling Frequency defaulting to 8000 Hz');

fsamp = 8000;

end

if (length(xx) < 1000)

disp('WARNING: Signal Length should be greater than 1000');

end

Lfft = Lsect;

Noverlap = round(Lsect/2);

[B,F,T] = spectgr(xx, Lfft, fsamp, Lsect, Noverlap);

Bdb = 20*log10(abs(B));

Bmax = max(Bdb(:));

Bdb = Bdb - Bmax;

Bmin = -DBrange;

Bdb = Bdb.*(Bdb>=Bmin)+ Bmin.*(Bdb<Bmin);

him = imagesc(T,F,Bdb);

axis xy;
xlabel('Time(sec)');
ylabel('Frequency(Hz)');
colormap(1-gray);
end

##### SOURCE END #####
--></body></html>